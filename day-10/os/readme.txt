第八天的课程：

关于鼠标是怎么移动怎来的。
现在忘掉作者的代码思路，如果是我们自己写代码，鼠标指针应该怎么样才能动起来呢？
我的思路：
其实让鼠标指针动起来真的非常简单，只需要改变下面函数中的mx,my变量，也就是鼠标的position变量，鼠标指针就会移动了。但是在移动前一定要把原来鼠标指针出现的位置填充为背景
色，这样就不出现鼠标移动的轨迹了。

display_mouse(bootp->vram,bootp->xsize,16,16,mx,my,mousepic,16);

这个函数就可以把鼠标原来出现过的地方填充为背景色，白色。
 boxfill(white,mx,my,mx+15,my+15);

我们可以写这样的函数：
for(i=0;i++;i<8)
{
display_mouse(bootp->vram,bootp->xsize,16,16,mx,my,mousepic,16);
sleep(1);/sleep 1 second 
boxfill(white,mx,my,mx+15,my+15);
mx=mx+15;
}

//上面的函数就会使 鼠标的函数指针每过1s，就在x方向移动15个像素点

所以移动鼠标的基本思想就是 1：用背景色把原来鼠标出现过的位置填充掉 
		       2：改变mx,my(就是表示鼠标位置的变量)，然后用
                        display_mouse(bootp->vram,bootp->xsize,16,16,mx,my,mousepic,16);函数重新显示鼠标指针


但是现在有个难点就是我们手上的硬件左移时，怎么得到左移这个变量，然后把这个变量反应到mx变化上面。

当我们手上的鼠标移动时，会产生中断，然后我们从中断服务程序中得到鼠标硬件产生的数据，鼠标比较特别，需要从三个中断服务程序中得三个有效的数据，才能正确的反应出鼠标当前的位置信息。

当我们用某种方法得到三个字节的鼠标信息后(保存在buffer[0],buffer[1],buffer[2])，只要对这三个字节的内容进行正确的解读，就能得到鼠标是否有左右键按下，是向哪个方向移动了。

buffer[0] 低4位主要反应按键 按下情况：0:no key press 1:left press 2:right 3:both 4:middle press
	  高4位中低2位与x,y的移动方向有关，当bit4为1时，表示鼠标向－x方向移动，当bit5为1时表示鼠标向-y方向移动

对于buffer[1]就是包含了在x方向上移动的增量，移动的快，这个增量就大，移动慢，这个增量就小.一定注意这是一个增量。例如：当buffer[1]=4时，表示在x方向移动的速度增量只有4，
再结合buffer[0]的bit4位，就可以知道是向x正方向移动(bit4=0)，还是x负方向移动（bit4=1）
对于buffer[2]就是包含了在y方向上移动的增量，移动的快，这个增量就大，移动慢，这个增量就小.一定注意这是一个增量。

所以只需要把有方向量的buffer[1]增量,加在mx上；mx=mx+buffer[1]，就可以根据硬件上鼠标的移动，来反应到屏幕上鼠标指针位置的改变。


这样就把从三个中断服务程序中，硬件鼠标得到三个字节的数据buffer[0],buffer[1],buffer[2] 与 屏幕上鼠标指针位置mx,my联系起来，
每次根据新的mx,my重绘鼠标指针之前，需要把原来鼠标出现的位置填充为背景色，以免出现鼠标运行的轨迹。

整个思路有了，就是程序上如何实现了。

 mouse_decode(struct MOUSE_DEC *mdec,unsigned char data)这个函数就是从得到三个字节数据中解读出dx,dy 还有button的情况。
 
 下面的几个if判断完全是为了防止鼠标指针跑出了屏幕的边界。
       if(mx<0)
	      {
		mx=0;
	      }
	      if(my<0)
	      {
		my=0;
	      }
	      
	      
	      if(mx>bootp->xsize-16)
	      {
		mx=bootp->xsize-16;
	      }
	      
	      if(my>bootp->ysize-16)
	      {
		my=bootp->ysize-16;
	      }
 
 
//其它的部分也就顺理成章了。






